//------------------------------------------------------------------
// Proxy Unit Generated by Delphi Microservices Container 4.1.28
// Do not modify this unit!
// Generated at: 2021-10-22 19:00:29
//------------------------------------------------------------------
unit SynchUtilsRPCProxy;

interface

uses
  System.SysUtils,
  System.Classes,
  MVCFramework.JSONRPC,
  MVCFramework.JSONRPC.Client,
  MVCFramework.Serializer.Commons,
  System.Net.URLClient,
  JsonDataObjects;

type
  ISynchUtilsRPCProxy = interface
  ['{9CCF7C7A-E0D1-46A1-B096-3C4DDFB475EF}']
    function RPCExecutor: IMVCJSONRPCExecutor;
    procedure IgnoreInvalidCert;
    /// <summary>
    /// Invokes [function TryAcquireLock(const Token: string; const LockIdentifier: string; const LockTTL: Int64; const LockData: TJsonObject): string]
    /// Tries to acquire an exclusive lock on `LockIdentifier` for a max of `LockTTL` minutes, optionally attaching the data contained in `LockData`.
    /// TryAcquireLock calls cannot be nested - a subsequent call with same LockIdentifier tryies to re-acquire the lock.
    /// If the lock has been acquired, TryAcquireLock returns a <LockHandle> (a random string) that need to be used to estend or release the lock.
    /// If cannot acquire lock, returns the const string "error"
    /// </summary>
    function TryAcquireLock(const Token: string; const LockIdentifier: string; const LockTTL: Int64; const LockData: TJsonObject): string;
    /// <summary>
    /// Invokes [function ExtendLock(const Token: string; const LockTTL: Int64; const LockHandle: string): Boolean]
    /// Allows to extend the LockTTL for an owned-lock. LockExtender is the token returned by the TryAcquireLock call. Lock extension starts from "now" for LockTTL seconds.
    /// </summary>
    function ExtendLock(const Token: string; const LockTTL: Int64; const LockHandle: string): Boolean;
    /// <summary>
    /// Invokes [function GetLockData(const Token: string; const LockIdentifier: string): TJsonObject]
    /// Get the lock data from an exclusive lock (owned, or not owned, by the user). If the lock doesn't exist, an exception raise.
    /// </summary>
    function GetLockData(const Token: string; const LockIdentifier: string): TJDOJsonObject;
    /// <summary>
    /// Invokes [function GetLockExpiration(const Token: string; const LockIdentifier: string): Int64]
    /// Returns the time remaining for the natural exclusive lock expiration and the LockData.If the lock doesn't exists raises an exception.
    /// </summary>
    function GetLockExpiration(const Token: string; const LockIdentifier: string): Int64;
    /// <summary>
    /// Invokes [function GetExclusiveLockQueueName(const Token: string; const LockIdentifier: string): TJsonObject]
    /// Returns the system queue where any change to the lock status is published.
    /// </summary>
    function GetExclusiveLockQueueName(const Token: string; const LockIdentifier: string): TJDOJsonObject;
    /// <summary>
    /// Invokes [function ReleaseLock(const Token: string; const LockHandle: string): Boolean]
    /// Release an owned exclusive lock and return true. If the lock doesn't exist or is not owned by the current user, return false.
    /// </summary>
    function ReleaseLock(const Token: string; const LockHandle: string): Boolean;
    /// <summary>
    /// Invokes [function GetLocks(const Token: string): TJsonObject]
    /// Returns all active locks - only ADMIN and MONITOR roles can call this method
    /// </summary>
    function GetLocks(const Token: string): TJDOJsonObject;
    /// <summary>
    /// Invokes [function Login(const UserName: string; const Password: string): TJsonObject]
    /// Returns the JWT token which can be used to call all other methods.
    /// </summary>
    function Login(const UserName: string; const Password: string): TJDOJsonObject;
    /// <summary>
    /// Invokes [function RefreshToken(const Token: string): TJsonObject]
    /// Extends the expiration time of a still-valid token. Clients must use the token returned instead of the previous one.
    /// </summary>
    function RefreshToken(const Token: string): TJDOJsonObject;
  end;

  TSynchUtilsRPCProxy = class(TInterfacedObject, ISynchUtilsRPCProxy)
  protected
    fRPCExecutor: IMVCJSONRPCExecutor;
    function NewReqID: Int64;
    procedure IgnoreInvalidServerCertificate(const Sender: TObject;
      const ARequest: TURLRequest; const Certificate: TCertificate; var Accepted: Boolean);
  public
    function RPCExecutor: IMVCJSONRPCExecutor;
    procedure IgnoreInvalidCert;
    constructor Create(const EndpointURL: String); virtual;
    /// <summary>
    /// Invokes [function TryAcquireLock(const Token: string; const LockIdentifier: string; const LockTTL: Int64; const LockData: TJsonObject): string]
    /// Tries to acquire an exclusive lock on `LockIdentifier` for a max of `LockTTL` minutes, optionally attaching the data contained in `LockData`.
    /// TryAcquireLock calls cannot be nested - a subsequent call with same LockIdentifier tryies to re-acquire the lock.
    /// If the lock has been acquired, TryAcquireLock returns a <LockHandle> (a random string) that need to be used to estend or release the lock.
    /// If cannot acquire lock, returns the const string "error"
    /// </summary>
    function TryAcquireLock(const Token: string; const LockIdentifier: string; const LockTTL: Int64; const LockData: TJsonObject): string;
    /// <summary>
    /// Invokes [function ExtendLock(const Token: string; const LockTTL: Int64; const LockHandle: string): Boolean]
    /// Allows to extend the LockTTL for an owned-lock. LockExtender is the token returned by the TryAcquireLock call. Lock extension starts from "now" for LockTTL seconds.
    /// </summary>
    function ExtendLock(const Token: string; const LockTTL: Int64; const LockHandle: string): Boolean;
    /// <summary>
    /// Invokes [function GetLockData(const Token: string; const LockIdentifier: string): TJsonObject]
    /// Get the lock data from an exclusive lock (owned, or not owned, by the user). If the lock doesn't exist, an exception raise.
    /// </summary>
    function GetLockData(const Token: string; const LockIdentifier: string): TJDOJsonObject;
    /// <summary>
    /// Invokes [function GetLockExpiration(const Token: string; const LockIdentifier: string): Int64]
    /// Returns the time remaining for the natural exclusive lock expiration and the LockData.If the lock doesn't exists raises an exception.
    /// </summary>
    function GetLockExpiration(const Token: string; const LockIdentifier: string): Int64;
    /// <summary>
    /// Invokes [function GetExclusiveLockQueueName(const Token: string; const LockIdentifier: string): TJsonObject]
    /// Returns the system queue where any change to the lock status is published.
    /// </summary>
    function GetExclusiveLockQueueName(const Token: string; const LockIdentifier: string): TJDOJsonObject;
    /// <summary>
    /// Invokes [function ReleaseLock(const Token: string; const LockHandle: string): Boolean]
    /// Release an owned exclusive lock and return true. If the lock doesn't exist or is not owned by the current user, return false.
    /// </summary>
    function ReleaseLock(const Token: string; const LockHandle: string): Boolean;
    /// <summary>
    /// Invokes [function GetLocks(const Token: string): TJsonObject]
    /// Returns all active locks - only ADMIN and MONITOR roles can call this method
    /// </summary>
    function GetLocks(const Token: string): TJDOJsonObject;
    /// <summary>
    /// Invokes [function Login(const UserName: string; const Password: string): TJsonObject]
    /// Returns the JWT token which can be used to call all other methods.
    /// </summary>
    function Login(const UserName: string; const Password: string): TJDOJsonObject;
    /// <summary>
    /// Invokes [function RefreshToken(const Token: string): TJsonObject]
    /// Extends the expiration time of a still-valid token. Clients must use the token returned instead of the previous one.
    /// </summary>
    function RefreshToken(const Token: string): TJDOJsonObject;
end;

implementation

constructor TSynchUtilsRPCProxy.Create(const EndpointURL: String);
begin
  inherited Create;
  fRPCExecutor := TMVCJSONRPCExecutor.Create(EndpointURL);
  fRPCExecutor.AddHTTPHeader(TNetHeader.Create('Accept-Encoding', 'gzip,deflate'));
  fRPCExecutor.AddHTTPHeader(TNetHeader.Create('User-Agent', 'dmscontainer-delphi-proxy'));

end;

function TSynchUtilsRPCProxy.NewReqID: Int64;
begin
  Result := 10000 + Random(10000000);
end;

function TSynchUtilsRPCProxy.RPCExecutor: IMVCJSONRPCExecutor;
begin
  Result := fRPCExecutor;
end;

procedure TSynchUtilsRPCProxy.IgnoreInvalidCert;
begin
  fRPCExecutor.SetOnValidateServerCertificate(IgnoreInvalidServerCertificate);
end;

procedure TSynchUtilsRPCProxy.IgnoreInvalidServerCertificate(
  const Sender: TObject; const ARequest: TURLRequest;
  const Certificate: TCertificate; var Accepted: Boolean);
begin
  Accepted := True;
end;


function TSynchUtilsRPCProxy.TryAcquireLock(const Token: string; const LockIdentifier: string; const LockTTL: Int64; const LockData: TJsonObject): string;
var
  lReq: IJSONRPCRequest;
  lResp: IJSONRPCResponse;
begin
  lReq := TJSONRPCRequest.Create(NewReqID, 'TryAcquireLock');
  lReq.Params.Add(Token);
  lReq.Params.Add(LockIdentifier);
  lReq.Params.Add(LockTTL, TJSONRPCParamDataType.pdtLongInteger);
  lReq.Params.Add(LockData);
  lResp := fRPCExecutor.ExecuteRequest(lReq);
  Result := lResp.Result.AsString;
end;


function TSynchUtilsRPCProxy.ExtendLock(const Token: string; const LockTTL: Int64; const LockHandle: string): Boolean;
var
  lReq: IJSONRPCRequest;
  lResp: IJSONRPCResponse;
begin
  lReq := TJSONRPCRequest.Create(NewReqID, 'ExtendLock');
  lReq.Params.Add(Token);
  lReq.Params.Add(LockTTL, TJSONRPCParamDataType.pdtLongInteger);
  lReq.Params.Add(LockHandle);
  lResp := fRPCExecutor.ExecuteRequest(lReq);
  Result := lResp.Result.AsBoolean;
end;


function TSynchUtilsRPCProxy.GetLockData(const Token: string; const LockIdentifier: string): TJDOJsonObject;
var
  lReq: IJSONRPCRequest;
  lResp: IJSONRPCResponse;
begin
  lReq := TJSONRPCRequest.Create(NewReqID, 'GetLockData');
  lReq.Params.Add(Token);
  lReq.Params.Add(LockIdentifier);
  lResp := fRPCExecutor.ExecuteRequest(lReq);
  Result := lResp.ResultAsJSONObject.Clone as TJDOJsonObject; //TJsonObject
end;


function TSynchUtilsRPCProxy.GetLockExpiration(const Token: string; const LockIdentifier: string): Int64;
var
  lReq: IJSONRPCRequest;
  lResp: IJSONRPCResponse;
begin
  lReq := TJSONRPCRequest.Create(NewReqID, 'GetLockExpiration');
  lReq.Params.Add(Token);
  lReq.Params.Add(LockIdentifier);
  lResp := fRPCExecutor.ExecuteRequest(lReq);
  Result := lResp.Result.AsInt64;
end;


function TSynchUtilsRPCProxy.GetExclusiveLockQueueName(const Token: string; const LockIdentifier: string): TJDOJsonObject;
var
  lReq: IJSONRPCRequest;
  lResp: IJSONRPCResponse;
begin
  lReq := TJSONRPCRequest.Create(NewReqID, 'GetExclusiveLockQueueName');
  lReq.Params.Add(Token);
  lReq.Params.Add(LockIdentifier);
  lResp := fRPCExecutor.ExecuteRequest(lReq);
  Result := lResp.ResultAsJSONObject.Clone as TJDOJsonObject; //TJsonObject
end;


function TSynchUtilsRPCProxy.ReleaseLock(const Token: string; const LockHandle: string): Boolean;
var
  lReq: IJSONRPCRequest;
  lResp: IJSONRPCResponse;
begin
  lReq := TJSONRPCRequest.Create(NewReqID, 'ReleaseLock');
  lReq.Params.Add(Token);
  lReq.Params.Add(LockHandle);
  lResp := fRPCExecutor.ExecuteRequest(lReq);
  Result := lResp.Result.AsBoolean;
end;


function TSynchUtilsRPCProxy.GetLocks(const Token: string): TJDOJsonObject;
var
  lReq: IJSONRPCRequest;
  lResp: IJSONRPCResponse;
begin
  lReq := TJSONRPCRequest.Create(NewReqID, 'GetLocks');
  lReq.Params.Add(Token);
  lResp := fRPCExecutor.ExecuteRequest(lReq);
  Result := lResp.ResultAsJSONObject.Clone as TJDOJsonObject; //TJsonObject
end;


function TSynchUtilsRPCProxy.Login(const UserName: string; const Password: string): TJDOJsonObject;
var
  lReq: IJSONRPCRequest;
  lResp: IJSONRPCResponse;
begin
  lReq := TJSONRPCRequest.Create(NewReqID, 'Login');
  lReq.Params.Add(UserName);
  lReq.Params.Add(Password);
  lResp := fRPCExecutor.ExecuteRequest(lReq);
  Result := lResp.ResultAsJSONObject.Clone as TJDOJsonObject; //TJsonObject
end;


function TSynchUtilsRPCProxy.RefreshToken(const Token: string): TJDOJsonObject;
var
  lReq: IJSONRPCRequest;
  lResp: IJSONRPCResponse;
begin
  lReq := TJSONRPCRequest.Create(NewReqID, 'RefreshToken');
  lReq.Params.Add(Token);
  lResp := fRPCExecutor.ExecuteRequest(lReq);
  Result := lResp.ResultAsJSONObject.Clone as TJDOJsonObject; //TJsonObject
end;

end.
