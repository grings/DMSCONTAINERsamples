#------------------------------------------------------------------
# Proxy Script Generated by Delphi Microservices Container 4.1.28
# Do not modify this code!
# Generated at: 2021-10-22 19:02:08
#------------------------------------------------------------------

import requests
import urllib3

urllib3.disable_warnings()

class SynchUtilsRPCException(Exception):
    pass

class SynchUtilsRPCProxy:
    def __init__(self, base_url):
        self.__id = 1
        self.base_url = base_url
        self.headers = {
            "content-type": "application/json",
            "accept": "application/json"
        }

    def __get_next_id(self):
        self.__id += 1
        return self.__id

    def __execute(self, req):
        isnotif = req.get("id") is None
        res = requests.post(self.base_url, json=req, headers=self.headers, verify=False)
        if res.status_code == 204:  # no content
            if isnotif:
              return None
            else:
              raise SynchUtilsRPCException(0,"Protocol error for Notification")
        if res.headers["content-type"].lower().find("application/json") != 0:
            raise SynchUtilsRPCException("Invalid ContentType in response: " + res.headers["content-type"])
        jres = res.json()
        if jres.get("error"):
           raise SynchUtilsRPCException(jres.get("error").get("message"))
        if not jres.get("result"):
            raise SynchUtilsRPCException(0,"Protocol error for Request")
        return jres["result"]

    def __new_req(self, method, typ):
        req = dict(jsonrpc="2.0", method=method, params=[])
        if typ == "request":
           req["id"] = self.__get_next_id()
        return req
# end of library code

# Following methods are automatically generated

    def try_acquire_lock(self, token, lockidentifier, lockttl, lockdata):
        """
        Invokes [function TryAcquireLock(const Token: string; const LockIdentifier: string; const LockTTL: Int64; const LockData: TJsonObject): string]
        Tries to acquire an exclusive lock on `LockIdentifier` for a max of `LockTTL` minutes, optionally attaching the data contained in `LockData`. 
        TryAcquireLock calls cannot be nested - a subsequent call with same LockIdentifier tryies to re-acquire the lock.
        If the lock has been acquired, TryAcquireLock returns a <LockHandle> (a random string) that need to be used to estend or release the lock.
        If cannot acquire lock, returns the const string "error"
        """
        req = self.__new_req("TryAcquireLock", "request")
        req["params"].append(token)
        req["params"].append(lockidentifier)
        req["params"].append(lockttl)
        req["params"].append(lockdata)
        result = self.__execute(req)
        return result

    def extend_lock(self, token, lockttl, lockhandle):
        """
        Invokes [function ExtendLock(const Token: string; const LockTTL: Int64; const LockHandle: string): Boolean]
        Allows to extend the LockTTL for an owned-lock. LockExtender is the token returned by the TryAcquireLock call. Lock extension starts from "now" for LockTTL seconds.
        """
        req = self.__new_req("ExtendLock", "request")
        req["params"].append(token)
        req["params"].append(lockttl)
        req["params"].append(lockhandle)
        result = self.__execute(req)
        return result

    def get_lock_data(self, token, lockidentifier):
        """
        Invokes [function GetLockData(const Token: string; const LockIdentifier: string): TJsonObject]
        Get the lock data from an exclusive lock (owned, or not owned, by the user). If the lock doesn't exist, an exception raise.
        """
        req = self.__new_req("GetLockData", "request")
        req["params"].append(token)
        req["params"].append(lockidentifier)
        result = self.__execute(req)
        return result

    def get_lock_expiration(self, token, lockidentifier):
        """
        Invokes [function GetLockExpiration(const Token: string; const LockIdentifier: string): Int64]
        Returns the time remaining for the natural exclusive lock expiration and the LockData.If the lock doesn't exists raises an exception.
        """
        req = self.__new_req("GetLockExpiration", "request")
        req["params"].append(token)
        req["params"].append(lockidentifier)
        result = self.__execute(req)
        return result

    def get_exclusive_lock_queue_name(self, token, lockidentifier):
        """
        Invokes [function GetExclusiveLockQueueName(const Token: string; const LockIdentifier: string): TJsonObject]
        Returns the system queue where any change to the lock status is published.
        """
        req = self.__new_req("GetExclusiveLockQueueName", "request")
        req["params"].append(token)
        req["params"].append(lockidentifier)
        result = self.__execute(req)
        return result

    def release_lock(self, token, lockhandle):
        """
        Invokes [function ReleaseLock(const Token: string; const LockHandle: string): Boolean]
        Release an owned exclusive lock and return true. If the lock doesn't exist or is not owned by the current user, return false.
        """
        req = self.__new_req("ReleaseLock", "request")
        req["params"].append(token)
        req["params"].append(lockhandle)
        result = self.__execute(req)
        return result

    def get_locks(self, token):
        """
        Invokes [function GetLocks(const Token: string): TJsonObject]
        Returns all active locks - only ADMIN and MONITOR roles can call this method
        """
        req = self.__new_req("GetLocks", "request")
        req["params"].append(token)
        result = self.__execute(req)
        return result

    def login(self, username, password):
        """
        Invokes [function Login(const UserName: string; const Password: string): TJsonObject]
        Returns the JWT token which can be used to call all other methods.
        """
        req = self.__new_req("Login", "request")
        req["params"].append(username)
        req["params"].append(password)
        result = self.__execute(req)
        return result

    def refresh_token(self, token):
        """
        Invokes [function RefreshToken(const Token: string): TJsonObject]
        Extends the expiration time of a still-valid token. Clients must use the token returned instead of the previous one.
        """
        req = self.__new_req("RefreshToken", "request")
        req["params"].append(token)
        result = self.__execute(req)
        return result

# end of generated proxy