//------------------------------------------------------------------
// Proxy Script Generated by Delphi Microservices Container 4.0.8
// Do not modify this code!
// Generated at: 2020-11-13 14:48:25
//------------------------------------------------------------------

export class EventStreamsRPCProxy {
    __baseUrl = "";
    constructor(baseUrl) {
        this.__baseUrl = baseUrl;
    }

    get baseUrl() {
        return this.__baseUrl;
    }

    __getJsonRpcRequest(jsonrpcRequestMethod, params) {
        let json = this.__getJsonRpcNotification(jsonrpcRequestMethod, params);
        json["id"] = Math.trunc(Math.random() * 100000);
        return json;
    }

    __getJsonRpcNotification(jsonrpcRequestMethod, params) {
        return {
            "jsonrpc": "2.0",
            "method": jsonrpcRequestMethod,
            "params": params
        };
    }

    __internalFetch(type, baseUrl, jsonrpcMethod, params) {
        let jsonbody = null;
        if (type === 'notification') {
            jsonbody = this.__getJsonRpcNotification(jsonrpcMethod, params);
        } else if (type === 'request') {
            jsonbody = this.__getJsonRpcRequest(jsonrpcMethod, params);
        }

        return fetch(baseUrl, {
            "method": "POST",
            "body": JSON.stringify(jsonbody),
            "headers": {
                "content-type": "application/json",
                "accept": "application/json"
            }
        }).then(data => {
            switch (data.status) {
                case 200:
                    {
                        return data.json();
                    }
                case 204:
                    {
                        //no content
                        return null;
                    }
                default:
                    {
                        return data.json();
                    }
            }
        });
    }

    __jsonRpcResponsePromise(type, baseUrl, method, params) {
        switch (type) {
            case "request":
                {
                    return new Promise((resolve, reject) => {
                        this.__internalFetch('request', this.baseUrl, method, params).then(jsonresp => {
                            if ("result" in jsonresp) {
                                resolve(jsonresp.result)
                            } else if ("error" in jsonresp) {
                                reject(jsonresp.error)
                            } else {
                                throw new Error("Invalid JSON-RPC response");
                            }
                        });
                    })
                    break;
                }
            case "notification":
                {
                    return new Promise((resolve, reject) => {
                        this.__internalFetch('notification', this.baseUrl, method, params).then(jsonresp => {
                            if (jsonresp !== null && "error" in jsonresp) {
                                reject(jsonresp.error);
                            } else {
                                resolve();
                            }
                        });
                    })
                    break;
                }
            default:
                {
                    throw new Error("JSON-RPC message must be 'request' or 'notification' [Actual: '" + type + '"]');
                }
        }
    }
// Following methods are automatically generated

    // Invokes [function Login(const UserName: string; const Password: string): TJsonObject]
    login(userName, password) {
      return this.__jsonRpcResponsePromise('request', this.__baseUrl, 'Login',{
        "userName": userName,
        "password": password
      });
    }

    // Invokes [function EnqueueMessage(const Token: string; const QueueName: string; Message: TJsonObject): TJsonObject]
    // Pushes a Message in a Queue
    enqueueMessage(token, queueName, message) {
      return this.__jsonRpcResponsePromise('request', this.__baseUrl, 'EnqueueMessage',{
        "token": token,
        "queueName": queueName,
        "message": message
      });
    }

    // Invokes [function EnqueueMultipleMessages(const Token: string; QueuesAndMessages: TJsonObject): TJsonObject]
    // Atomically pushes multiple messages to multiple queues
    enqueueMultipleMessages(token, queuesAndMessages) {
      return this.__jsonRpcResponsePromise('request', this.__baseUrl, 'EnqueueMultipleMessages',{
        "token": token,
        "queuesAndMessages": queuesAndMessages
      });
    }

    // Invokes [function DequeueMessage(const Token: string; const QueueName: string; LastKnownID: string; const TimeoutSec: Int64): TJsonObject]
    // Dequeue a Message from QueueName.
    // LastKnownID can be "__last__" (get the last message), "__first__" (get the first message) or any 
    // MessageID previously retrieved (get the first message with MessageID greater the LastKnownID).
    // If no message is available, it waits for TimeoutSec, then returns.  
    // Max allowed timeout is 5 minutes, min allowed timeout is 5 seconds
    dequeueMessage(token, queueName, lastKnownId, timeoutSec) {
      return this.__jsonRpcResponsePromise('request', this.__baseUrl, 'DequeueMessage',{
        "token": token,
        "queueName": queueName,
        "lastKnownId": lastKnownId,
        "timeoutSec": timeoutSec
      });
    }

    // Invokes [procedure DeleteQueue(const Token: string; const QueueName: string)]
    // Deletes queue named "QueueName"
    deleteQueue(token, queueName) {
      return this.__jsonRpcResponsePromise('notification', this.__baseUrl, 'DeleteQueue',{
        "token": token,
        "queueName": queueName
      });
    }

    // Invokes [function GetQueuesInfo(const Token: string; const NameFilter: string): TJsonObject]
    // Returns info about queues whose names starts with "NameFilter". 
    // If "NameFilter" is empty, all queues are returned
    getQueuesInfo(token, nameFilter) {
      return this.__jsonRpcResponsePromise('request', this.__baseUrl, 'GetQueuesInfo',{
        "token": token,
        "nameFilter": nameFilter
      });
    }

    // Invokes [function GetQueueSize(const Token: string; const QueueName: string): TJsonObject]
    // Returns the size (a.k.a. number of messages) of queue named "QueueName"
    getQueueSize(token, queueName) {
      return this.__jsonRpcResponsePromise('request', this.__baseUrl, 'GetQueueSize',{
        "token": token,
        "queueName": queueName
      });
    }

    // Invokes [function RefreshToken(const Token: string): TJsonObject]
    // Extends the expiration time of a still-valid token. Clients must use the token returned instead of the previous one.
    refreshToken(token) {
      return this.__jsonRpcResponsePromise('request', this.__baseUrl, 'RefreshToken',{
        "token": token
      });
    }

} //end