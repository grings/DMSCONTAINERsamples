//------------------------------------------------------------------
// Proxy Script Generated by Delphi Microservices Container 4.1.60
// Do not modify this code!
// Generated at: 2022-12-12 18:48:05
//------------------------------------------------------------------

export class CalculatorRPCProxy {
    __baseUrl = "";
    constructor(baseUrl) {
        this.__baseUrl = baseUrl;
    }

    get baseUrl() {
        return this.__baseUrl;
    }

    __getJsonRpcRequest(jsonrpcRequestMethod, params) {
        let json = this.__getJsonRpcNotification(jsonrpcRequestMethod, params);
        json["id"] = Math.trunc(Math.random() * 100000);
        return json;
    }

    __getJsonRpcNotification(jsonrpcRequestMethod, params) {
        return {
            "jsonrpc": "2.0",
            "method": jsonrpcRequestMethod,
            "params": params
        };
    }

    __internalFetch(type, baseUrl, jsonrpcMethod, params) {
        let jsonbody = null;
        if (type === 'notification') {
            jsonbody = this.__getJsonRpcNotification(jsonrpcMethod, params);
        } else if (type === 'request') {
            jsonbody = this.__getJsonRpcRequest(jsonrpcMethod, params);
        }

        return fetch(baseUrl, {
            "method": "POST",
            "body": JSON.stringify(jsonbody),
            "headers": {
                "content-type": "application/json",
                "accept": "application/json"
            }
        }).then(data => {
            switch (data.status) {
                case 200:
                    {
                        return data.json();
                    }
                case 204:
                    {
                        //no content
                        return null;
                    }
                default:
                    {
                        return data.json();
                    }
            }
        });
    }

    __jsonRpcResponsePromise(type, baseUrl, method, params) {
        switch (type) {
            case "request":
                {
                    return new Promise((resolve, reject) => {
                        this.__internalFetch('request', this.baseUrl, method, params).then(jsonresp => {
                            if ("result" in jsonresp) {
                                resolve(jsonresp.result)
                            } else if ("error" in jsonresp) {
                                reject(jsonresp.error)
                            } else {
                                throw new Error("Invalid JSON-RPC response");
                            }
                        });
                    })
                    break;
                }
            case "notification":
                {
                    return new Promise((resolve, reject) => {
                        this.__internalFetch('notification', this.baseUrl, method, params).then(jsonresp => {
                            if (jsonresp !== null && "error" in jsonresp) {
                                reject(jsonresp.error);
                            } else {
                                resolve();
                            }
                        });
                    })
                    break;
                }
            default:
                {
                    throw new Error("JSON-RPC message must be 'request' or 'notification' [Actual: '" + type + '"]');
                }
        }
    }
    // Following methods are automatically generated

    // Invokes [function Sum(const A: Integer; const B: Integer): Integer]
    // Returns the sum of two integers
    sum(a, b) {
        return this.__jsonRpcResponsePromise('request', this.__baseUrl, 'Sum', {
            "a": a,
            "b": b
        });
    }

    // Invokes [function Diff(const A: Integer; const B: Integer): Integer]
    // Returns the difference between two integers
    diff(a, b) {
        return this.__jsonRpcResponsePromise('request', this.__baseUrl, 'Diff', {
            "a": a,
            "b": b
        });
    }

} //end